#!/bin/bash

# This script spins up a local kubernetes cluster, builds the docker images, and deploys the appropriate chart.

# ARG_OPTIONAL_SINGLE([cpus],[],[The number of CPUs to allocate to the cluster],[4])
# ARG_OPTIONAL_SINGLE([memory],[],[The amount of memory in MB to allocate to the cluster],[4096])
# ARG_OPTIONAL_BOOLEAN([launch-dashboard],[d],[Launch the kubernetes dashboard])
# ARG_OPTIONAL_BOOLEAN([build],[b],[Build the docker images])
# ARG_OPTIONAL_SINGLE([tag],[t],[The tag to use on built docker image],[testing])
# ARG_OPTIONAL_BOOLEAN([client],[c],[Create the client resources])
# ARG_HELP([Script to help launch a local kubernetes cluster to test means of production server deployment.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='dbtch'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_cpus="4"
_arg_memory="4096"
_arg_launch_dashboard="off"
_arg_build="off"
_arg_tag="testing"
_arg_client="off"


print_help()
{
	printf '%s\n' "Script to help launch a local kubernetes cluster to test means of production server deployment."
	printf 'Usage: %s [--cpus <arg>] [--memory <arg>] [-d|--(no-)launch-dashboard] [-b|--(no-)build] [-t|--tag <arg>] [-c|--(no-)client] [-h|--help]\n' "$0"
	printf '\t%s\n' "--cpus: The number of CPUs to allocate to the cluster (default: '4')"
	printf '\t%s\n' "--memory: The amount of memory to allocate to the cluster (default: '4096')"
	printf '\t%s\n' "-d, --launch-dashboard, --no-launch-dashboard: Launch the kubernetes dashboard (off by default)"
	printf '\t%s\n' "-b, --build, --no-build: Build the docker images (off by default)"
	printf '\t%s\n' "-t, --tag: The tag to use on built docker image (default: 'testing')"
	printf '\t%s\n' "-c, --client, --no-client: Create the client resources (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			--cpus)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_cpus="$2"
				shift
				;;
			--cpus=*)
				_arg_cpus="${_key##--cpus=}"
				;;
			--memory)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_memory="$2"
				shift
				;;
			--memory=*)
				_arg_memory="${_key##--memory=}"
				;;
			-d|--no-launch-dashboard|--launch-dashboard)
				_arg_launch_dashboard="on"
				test "${1:0:5}" = "--no-" && _arg_launch_dashboard="off"
				;;
			-d*)
				_arg_launch_dashboard="on"
				_next="${_key##-d}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-b|--no-build|--build)
				_arg_build="on"
				test "${1:0:5}" = "--no-" && _arg_build="off"
				;;
			-b*)
				_arg_build="on"
				_next="${_key##-b}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-b" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-t|--tag)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_tag="$2"
				shift
				;;
			--tag=*)
				_arg_tag="${_key##--tag=}"
				;;
			-t*)
				_arg_tag="${_key##-t}"
				;;
			-c|--no-client|--client)
				_arg_client="on"
				test "${1:0:5}" = "--no-" && _arg_client="off"
				;;
			-c*)
				_arg_client="on"
				_next="${_key##-c}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-c" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash
# to regenerate run: argbash local-cluster.sh --in-place
# \/ marks code start

# check for dependencies
for dep in docker kubectl minikube; do
    missing_dep=false
    if ! which ${dep} > /dev/null; then
        echo "Missing dependency: '${dep}', please install to use this script" >&2
        missing_dep=true
    fi
    if ${missing_dep}; then
        exit 1
    fi
done

[[ -f .env ]] && source .env

if [[ -z "${MOP_DIR}" ]]; then
	server_dir=$(dirname $(dirname $(realpath $0)))
else
	server_dir="${MOP_DIR}/server"
fi

registry=""
if [ "${_arg_build}" = "on" ]; then
	# start local cluster with insecure registry to allow local building of images
	# make sure in cluster `imagePullPolicy: IfNotPresent` is set for relevant images
    registry="--insecure-registry"
fi

minikube profile means-of-production

# ensure local cluster running
cluster_status=$(minikube status --output json)
if [[ $(echo $cluster_status | jq -r '.Host') != 'Running' ]]; then
	minikube start "${registry}"  \
		--cpus ${_arg_cpus} --memory ${_arg_memory} \
		--driver docker
fi

# ensure kubectl configured
if [[ $(echo $cluster_status | jq -r '.Kubeconfig') != 'Configured' ]]; then
	minikube update-context
fi

# ensure docker env configured
if [[ $(echo $cluster_status | jq -r '.DockerEnv') != 'in-use' ]]; then
	eval $(minikube docker-env)
fi

if [ "${_arg_build}" = "on" ]; then
	# build the docker images
	docker build -t "means-of-production/server:${_arg_tag}" "$server_dir"
fi

# apply the manifest
kubectl apply -f "$server_dir/infra/kubernetes/server.yaml"

minikube service means-server --url

# /\ marks code end
# ] <-- needed because of Argbash
